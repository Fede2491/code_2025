# poisson con anche ttbar come fondo

import os
import csv
import random
import numpy as np
import cv2
from numpy.random import poisson
import matplotlib.pyplot as plt

# Percorsi delle immagini
path_HToBB = '/home/fede/Desktop/jet_patch_excl/Data_excl/HToBB_25_jet'
path_ZJetsToNuNu = '/home/fede/Desktop/jet_patch_excl/Data_excl/QCD_25_jet'
path_TTBar = '/home/fede/Desktop/jet_patch_excl/Data_excl/TTBar_25_jet'

# Funzioni
def get_image_path_full(path):
    images = [os.path.join(path, f) for f in os.listdir(path)
              if f.endswith('.jpg') and not f.startswith('.') and '.sys.' not in f]
    return images[0:9900]

def rotate_image(image, SIZE):
    angle = random.randint(0, 360)
    center = (SIZE // 2, SIZE // 2)
    M_rotation = cv2.getRotationMatrix2D(center, angle, 1)
    transformed_image = cv2.warpAffine(image, M_rotation, (SIZE, SIZE), borderMode=cv2.BORDER_CONSTANT, borderValue=0)
    return transformed_image

def get_bounding_box(image):
    non_zero_indices = np.argwhere(image > 0)
    if non_zero_indices.size == 0:
        return 0, 0, 0, 0
    ymin, xmin = non_zero_indices.min(axis=0)
    ymax, xmax = non_zero_indices.max(axis=0)
    width = xmax - xmin
    height = ymax - ymin
    return xmin, ymin, width, height

def place_image(image, bbox, matrix, mask):
    IMAGE_SIZE = 130
    MATRIX_SIZE = 512
    for _ in range(1000):
        x_start = random.randint(0, MATRIX_SIZE - IMAGE_SIZE)
        y_start = random.randint(0, MATRIX_SIZE - IMAGE_SIZE)
        selected_area = mask[y_start:y_start + IMAGE_SIZE, x_start:x_start + IMAGE_SIZE]
        if np.all(selected_area):
            matrix[y_start:y_start + IMAGE_SIZE, x_start:x_start + IMAGE_SIZE] = image
            mask[y_start:y_start + IMAGE_SIZE, x_start:x_start + IMAGE_SIZE] = False
            return x_start + bbox[0], y_start + bbox[1], bbox[2], bbox[3]
    return None

# Caricamento immagini
def load_and_process_images(paths, threshold=20, size=130):
    images = []
    bboxes = []
    for path in paths:
        image = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
        image = cv2.resize(image, (size, size))
        image = rotate_image(image, size)
        image[image < threshold] = 0
        images.append(image)
        bbox = get_bounding_box(image)
        bboxes.append(bbox)
    return images, bboxes

imgs_HToBB = get_image_path_full(path_HToBB)
imgs_QCD = get_image_path_full(path_ZJetsToNuNu)
imgs_TTBar = get_image_path_full(path_TTBar)  # Placeholder: da cambiare con path_TTBar

list_HToBB, bboxes_HToBB = load_and_process_images(imgs_HToBB)
list_QCD, bboxes_QCD = load_and_process_images(imgs_QCD)
list_TTBar, bboxes_TTBar = load_and_process_images(imgs_TTBar)

# Parametri
MATRIX_SIZE = 512
IMAGE_SIZE = 130
output_image_dir = "/home/fede/Desktop/jet_patch_excl/Test_poisson_distro/"
os.makedirs(output_image_dir, exist_ok=True)
output_csv_path = os.path.join(output_image_dir, "bounding_boxes_poisson.csv")

# Scrittura CSV
with open(output_csv_path, mode='w', newline='') as file:
    writer = csv.writer(file)
    header = ["image_name"]
    for obj in ["hbb", "qcd", "ttbar"]:
        for i in range(1, 6):
            header += [f"{obj}{i}_xmin", f"{obj}{i}_ymin", f"{obj}{i}_width", f"{obj}{i}_height"]
    header.append("label")
    writer.writerow(header)

    max_images = 3000
    hbb_counts = []
    qcd_counts = []
    ttbar_counts = []
    label_counts = []

    for idx in range(max_images):
        if not (list_HToBB or list_QCD or list_TTBar):
            break

        canvas = np.zeros((MATRIX_SIZE, MATRIX_SIZE), dtype=np.uint8)
        mask = np.ones((MATRIX_SIZE, MATRIX_SIZE), dtype=bool)
        entry = [f"image_poisson_{idx:04d}.jpg"]

        num_hbb = poisson(1)
        num_qcd = poisson(3)
        num_ttbar = poisson(3)

        total_requested = num_hbb + num_qcd + num_ttbar
        if total_requested > 5:
            scale = 5 / total_requested
            num_hbb = int(num_hbb * scale)
            num_qcd = int(num_qcd * scale)
            num_ttbar = int(num_ttbar * scale)


        if num_hbb > 0:
            label = 1
        elif num_qcd > 0:
            label = 0
        else:
            label = 2

        hbb_counts.append(num_hbb)
        qcd_counts.append(num_qcd)
        ttbar_counts.append(num_ttbar)
        label_counts.append(label)


        def place_and_record(images, bboxes, count):
            results = []
            for _ in range(5):
                if count > 0 and images:
                    img = images.pop(0)
                    bbox = bboxes.pop(0)
                    placed = place_image(img, bbox, canvas, mask)
                    if placed:
                        results.extend(placed)
                        count -= 1
                    else:
                        results.extend([""] * 4)
                else:
                    results.extend([""] * 4)
            return results

        entry += place_and_record(list_HToBB, bboxes_HToBB, num_hbb)
        entry += place_and_record(list_QCD, bboxes_QCD, num_qcd)
        entry += place_and_record(list_TTBar, bboxes_TTBar, num_ttbar)
        entry.append(label)

        cv2.imwrite(os.path.join(output_image_dir, entry[0]), canvas)
        writer.writerow(entry)
